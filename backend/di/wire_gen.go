// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package di

import (
	"context"
	service9 "github.com/goda6565/ai-consultant/backend/internal/domain/action/service"
	"github.com/goda6565/ai-consultant/backend/internal/domain/action/tools"
	service7 "github.com/goda6565/ai-consultant/backend/internal/domain/agent/service"
	service5 "github.com/goda6565/ai-consultant/backend/internal/domain/chunk/service"
	"github.com/goda6565/ai-consultant/backend/internal/domain/document/service"
	service4 "github.com/goda6565/ai-consultant/backend/internal/domain/hearing/service"
	service6 "github.com/goda6565/ai-consultant/backend/internal/domain/hearing_message/service"
	service2 "github.com/goda6565/ai-consultant/backend/internal/domain/problem/service"
	service3 "github.com/goda6565/ai-consultant/backend/internal/domain/problem_field/service"
	service8 "github.com/goda6565/ai-consultant/backend/internal/domain/prompt/service"
	"github.com/goda6565/ai-consultant/backend/internal/evaluate"
	"github.com/goda6565/ai-consultant/backend/internal/evaluate/proposal-job"
	"github.com/goda6565/ai-consultant/backend/internal/evaluate/proposal-job/llm-as-a-judge"
	"github.com/goda6565/ai-consultant/backend/internal/evaluate/proposal-job/memory"
	"github.com/goda6565/ai-consultant/backend/internal/evaluate/proposal-job/mock"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/environment"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/cloudrunjob"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/cloudtasks"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/database"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/database/repository/action"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/database/repository/chunk"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/database/repository/document"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/database/repository/hearing"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/database/repository/hearing_message"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/database/repository/job_config"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/database/repository/problem"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/database/repository/problem_field"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/database/repository/report"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/database/search"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/database/transaction"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/firebase"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/gemini"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/google_search"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/ocr"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/google/storage"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo/admin"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo/admin/handler"
	action3 "github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo/admin/handler/action"
	document3 "github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo/admin/handler/document"
	event3 "github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo/admin/handler/event"
	hearing3 "github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo/admin/handler/hearing"
	hearingmessage2 "github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo/admin/handler/hearing_message"
	jobconfig3 "github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo/admin/handler/job_config"
	problem3 "github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo/admin/handler/problem"
	report3 "github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo/admin/handler/report"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo/agent"
	handler3 "github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo/agent/handler"
	hearing4 "github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo/agent/handler/hearing"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo/vector"
	handler2 "github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo/vector/handler"
	chunk3 "github.com/goda6565/ai-consultant/backend/internal/infrastructure/http/echo/vector/handler/chunk"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/job"
	proposal2 "github.com/goda6565/ai-consultant/backend/internal/infrastructure/job/proposal"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/upstash/redis"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/upstash/redis/repository/event"
	"github.com/goda6565/ai-consultant/backend/internal/infrastructure/zap"
	action2 "github.com/goda6565/ai-consultant/backend/internal/usecase/action"
	chunk2 "github.com/goda6565/ai-consultant/backend/internal/usecase/chunk"
	document2 "github.com/goda6565/ai-consultant/backend/internal/usecase/document"
	event2 "github.com/goda6565/ai-consultant/backend/internal/usecase/event"
	hearing2 "github.com/goda6565/ai-consultant/backend/internal/usecase/hearing"
	"github.com/goda6565/ai-consultant/backend/internal/usecase/hearing_message"
	jobconfig2 "github.com/goda6565/ai-consultant/backend/internal/usecase/job_config"
	problem2 "github.com/goda6565/ai-consultant/backend/internal/usecase/problem"
	"github.com/goda6565/ai-consultant/backend/internal/usecase/proposal"
	report2 "github.com/goda6565/ai-consultant/backend/internal/usecase/report"
)

// Injectors from wire.go:

func InitAdminApplication(ctx context.Context) (*App, func(), error) {
	environmentEnvironment := environment.ProvideEnvironment()
	logger, cleanup := zap.ProvideZapLogger(environmentEnvironment)
	authenticator := firebase.NewFirebaseClient(ctx, environmentEnvironment)
	appPool, cleanup2 := database.ProvideAppPool(ctx, environmentEnvironment)
	documentRepository := document.NewDocumentRepository(appPool)
	storagePort := storage.NewClient(ctx)
	duplicateChecker := service.NewDuplicateCheckService(documentRepository)
	syncQueue, cleanup3 := cloudtasks.NewCloudTasksClient(ctx, environmentEnvironment)
	createDocumentInputPort := document2.NewCreateDocumentUseCase(environmentEnvironment, documentRepository, storagePort, duplicateChecker, syncQueue)
	createDocumentHandler := document3.NewCreateDocumentHandler(createDocumentInputPort)
	vectorPool, cleanup4 := database.ProvideVectorPool(ctx, environmentEnvironment)
	chunkRepository := chunk.NewChunkRepository(vectorPool)
	deleteDocumentInputPort := document2.NewDeleteDocumentUseCase(documentRepository, chunkRepository, storagePort)
	deleteDocumentHandler := document3.NewDeleteDocumentHandler(deleteDocumentInputPort)
	getDocumentInputPort := document2.NewGetDocumentUseCase(documentRepository)
	getDocumentHandler := document3.NewGetDocumentHandler(getDocumentInputPort)
	listDocumentInputPort := document2.NewListDocumentUseCase(documentRepository)
	listDocumentHandler := document3.NewListDocumentHandler(listDocumentInputPort)
	llmClient := gemini.NewGeminiClient(ctx, environmentEnvironment)
	generateTitleService := service2.NewGenerateTitleService(llmClient)
	problemRepository := problem.NewProblemRepository(appPool)
	problemFieldRepository := problemfield.NewProblemFieldRepository(appPool)
	generateProblemFieldService := service3.NewGenerateProblemFieldService(llmClient)
	hearingRepository := hearing.NewHearingRepository(appPool)
	hearingMessageRepository := hearingmessage.NewHearingMessageRepository(appPool)
	actionRepository := action.NewActionRepository(appPool)
	reportRepository := report.NewReportRepository(appPool)
	jobConfigRepository := jobconfig.NewJobConfigRepository(appPool)
	adminUnitOfWork := transaction.NewAdminUnitOfWork(ctx, appPool, documentRepository, problemRepository, hearingRepository, hearingMessageRepository, problemFieldRepository, actionRepository, reportRepository, jobConfigRepository)
	createProblemInputPort := problem2.NewCreateProblemUseCase(generateTitleService, problemRepository, problemFieldRepository, generateProblemFieldService, adminUnitOfWork)
	createProblemHandler := problem3.NewCreateProblemHandler(createProblemInputPort)
	deleteProblemInputPort := problem2.NewDeleteProblemUseCase(problemRepository, hearingMessageRepository, hearingRepository, actionRepository, adminUnitOfWork, reportRepository, jobConfigRepository)
	deleteProblemHandler := problem3.NewDeleteProblemHandler(deleteProblemInputPort)
	getProblemInputPort := problem2.NewGetProblemUseCase(problemRepository)
	getProblemHandler := problem3.NewGetProblemHandler(getProblemInputPort)
	listProblemInputPort := problem2.NewListProblemUseCase(problemRepository)
	listProblemHandler := problem3.NewListProblemHandler(listProblemInputPort)
	duplicateCheckerService := service4.NewDuplicateCheckerService(hearingRepository)
	createHearingInputPort := hearing2.NewCreateHearingUseCase(hearingRepository, duplicateCheckerService, adminUnitOfWork)
	createHearingHandler := hearing3.NewCreateHearingHandler(createHearingInputPort)
	getHearingInputPort := hearing2.NewGetHearingUseCase(hearingRepository)
	getHearingHandler := hearing3.NewGetHearingHandler(getHearingInputPort)
	listHearingMessageInputPort := hearing_message.NewListHearingMessageUseCase(hearingMessageRepository)
	listHearingMessageHandler := hearingmessage2.NewListHearingMessageHandler(listHearingMessageInputPort)
	client, cleanup5 := redis.ProvideRedisClient(ctx, environmentEnvironment)
	eventRepository := event.NewRedisEventRepository(client)
	listEventInputPort := event2.NewListEventUseCase(eventRepository)
	listEventHandler := event3.NewListEventHandler(listEventInputPort)
	getReportInputPort := report2.NewGetReportUseCase(reportRepository)
	getReportHandler := report3.NewGetReportHandler(getReportInputPort)
	listActionInputPort := action2.NewListActionUseCase(actionRepository)
	listActionHandler := action3.NewListActionHandler(listActionInputPort)
	updateJobConfigInputPort := jobconfig2.NewUpdateJobConfigUseCase(jobConfigRepository)
	updateJobConfigHandler := jobconfig3.NewUpdateJobConfigHandler(updateJobConfigInputPort)
	getJobConfigInputPort := jobconfig2.NewGetJobConfigUseCase(jobConfigRepository)
	getJobConfigHandler := jobconfig3.NewGetJobConfigHandler(getJobConfigInputPort)
	strictServerInterface := handler.NewAdminHandlers(createDocumentHandler, deleteDocumentHandler, getDocumentHandler, listDocumentHandler, createProblemHandler, deleteProblemHandler, getProblemHandler, listProblemHandler, createHearingHandler, getHearingHandler, listHearingMessageHandler, listEventHandler, getReportHandler, listActionHandler, updateJobConfigHandler, getJobConfigHandler)
	streamEventInputPort := event2.NewStreamEventUseCase(eventRepository)
	streamEventHandler := event3.NewStreamEventHandler(streamEventInputPort)
	adminHandlers := &handler.AdminHandlers{
		Rest:   strictServerInterface,
		Stream: streamEventHandler,
	}
	router := admin.NewAdminRouter(authenticator, adminHandlers, environmentEnvironment)
	server := echo.NewBaseServer(environmentEnvironment, logger, router)
	app := &App{
		Server: server,
	}
	return app, func() {
		cleanup5()
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

func InitVectorApplication(ctx context.Context) (*App, func(), error) {
	environmentEnvironment := environment.ProvideEnvironment()
	logger, cleanup := zap.ProvideZapLogger(environmentEnvironment)
	vectorPool, cleanup2 := database.ProvideVectorPool(ctx, environmentEnvironment)
	chunkRepository := chunk.NewChunkRepository(vectorPool)
	vectorUnitOfWork := transaction.NewVectorUnitOfWork(ctx, vectorPool, chunkRepository)
	appPool, cleanup3 := database.ProvideAppPool(ctx, environmentEnvironment)
	documentRepository := document.NewDocumentRepository(appPool)
	ocrClient := ocr.NewDocumentAIClient(ctx, environmentEnvironment)
	pdfParser := service5.NewPdfParserService(ocrClient)
	llmClient := gemini.NewGeminiClient(ctx, environmentEnvironment)
	csvAnalyzer := service5.NewCsvAnalyzerService(llmClient)
	chunker := service5.NewChunkService()
	storagePort := storage.NewClient(ctx)
	createChunkInputPort := chunk2.NewCreateChunkUseCase(vectorUnitOfWork, documentRepository, pdfParser, csvAnalyzer, chunker, storagePort, llmClient)
	createHandler := chunk3.NewCreateChunkHandler(createChunkInputPort)
	chunkHandlers := chunk3.ChunkHandlers{
		Create: createHandler,
	}
	vectorHandlers := &handler2.VectorHandlers{
		Chunk: chunkHandlers,
	}
	router := vector.NewVectorRouter(vectorHandlers)
	server := echo.NewBaseServer(environmentEnvironment, logger, router)
	app := &App{
		Server: server,
	}
	return app, func() {
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

func InitAgentApplication(ctx context.Context) (*App, func(), error) {
	environmentEnvironment := environment.ProvideEnvironment()
	logger, cleanup := zap.ProvideZapLogger(environmentEnvironment)
	authenticator := firebase.NewFirebaseClient(ctx, environmentEnvironment)
	appPool, cleanup2 := database.ProvideAppPool(ctx, environmentEnvironment)
	hearingRepository := hearing.NewHearingRepository(appPool)
	hearingMessageRepository := hearingmessage.NewHearingMessageRepository(appPool)
	problemRepository := problem.NewProblemRepository(appPool)
	problemFieldRepository := problemfield.NewProblemFieldRepository(appPool)
	duplicateCheckerService := service4.NewDuplicateCheckerService(hearingRepository)
	llmClient := gemini.NewGeminiClient(ctx, environmentEnvironment)
	generateHearingMessageService := service6.NewGenerateHearingMessageService(llmClient)
	judgeProblemFieldCompletionService := service3.NewJudgeProblemFieldCompletionService(llmClient)
	documentRepository := document.NewDocumentRepository(appPool)
	actionRepository := action.NewActionRepository(appPool)
	reportRepository := report.NewReportRepository(appPool)
	jobConfigRepository := jobconfig.NewJobConfigRepository(appPool)
	adminUnitOfWork := transaction.NewAdminUnitOfWork(ctx, appPool, documentRepository, problemRepository, hearingRepository, hearingMessageRepository, problemFieldRepository, actionRepository, reportRepository, jobConfigRepository)
	job, err := cloudrunjob.NewCloudRunJobClient(ctx, environmentEnvironment)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	executeHearingInputPort := hearing2.NewExecuteHearingUseCase(hearingRepository, hearingMessageRepository, problemRepository, problemFieldRepository, duplicateCheckerService, generateHearingMessageService, judgeProblemFieldCompletionService, adminUnitOfWork, job, environmentEnvironment)
	getProblemInputPort := problem2.NewGetProblemUseCase(problemRepository)
	executeHearingHandler := hearing4.NewExecuteHearingHandler(executeHearingInputPort, getProblemInputPort)
	strictServerInterface := handler3.NewAgentHandlers(executeHearingHandler)
	router := agent.NewAgentRouter(authenticator, strictServerInterface, environmentEnvironment, logger)
	server := echo.NewBaseServer(environmentEnvironment, logger, router)
	app := &App{
		Server: server,
	}
	return app, func() {
		cleanup2()
		cleanup()
	}, nil
}

func InitProposalJob(ctx context.Context) (*Job, func(), error) {
	environmentEnvironment := environment.ProvideEnvironment()
	logger, cleanup := zap.ProvideZapLogger(environmentEnvironment)
	appPool, cleanup2 := database.ProvideAppPool(ctx, environmentEnvironment)
	problemRepository := problem.NewProblemRepository(appPool)
	problemFieldRepository := problemfield.NewProblemFieldRepository(appPool)
	hearingRepository := hearing.NewHearingRepository(appPool)
	hearingMessageRepository := hearingmessage.NewHearingMessageRepository(appPool)
	actionRepository := action.NewActionRepository(appPool)
	client, cleanup3 := redis.ProvideRedisClient(ctx, environmentEnvironment)
	eventRepository := event.NewRedisEventRepository(client)
	llmClient := gemini.NewGeminiClient(ctx, environmentEnvironment)
	orchestrator := service7.NewOrchestrator(llmClient)
	summarizeService := service7.NewSummarizeService(llmClient)
	goalService := service7.NewGoalService(llmClient)
	terminator := service7.NewTerminator(llmClient)
	skipper := service7.NewSkipper(llmClient)
	promptBuilder := service8.NewPromptBuilder()
	planActionInterface := service9.NewPlanAction(llmClient, promptBuilder)
	webSearchClient := googlesearch.NewGoogleSearchClient(environmentEnvironment)
	vectorPool, cleanup4 := database.ProvideVectorPool(ctx, environmentEnvironment)
	documentSearchClient := search.NewSearchClient(vectorPool, appPool)
	searchTools := tools.NewSearchTools(llmClient, webSearchClient, documentSearchClient)
	externalSearchActionInterface := service9.NewExternalSearchAction(llmClient, searchTools, promptBuilder)
	internalSearchActionInterface := service9.NewInternalSearchAction(llmClient, searchTools, promptBuilder)
	analyzeActionInterface := service9.NewAnalyzeAction(llmClient, promptBuilder)
	writeActionInterface := service9.NewWriteAction(llmClient, promptBuilder)
	reviewActionInterface := service9.NewReviewAction(llmClient, promptBuilder)
	actionFactory := service9.NewActionFactory(planActionInterface, externalSearchActionInterface, internalSearchActionInterface, analyzeActionInterface, writeActionInterface, reviewActionInterface)
	reportRepository := report.NewReportRepository(appPool)
	jobConfigRepository := jobconfig.NewJobConfigRepository(appPool)
	executeProposalInputPort := proposal.NewExecuteProposalUseCase(problemRepository, problemFieldRepository, hearingRepository, hearingMessageRepository, actionRepository, eventRepository, orchestrator, summarizeService, goalService, terminator, skipper, actionFactory, reportRepository, jobConfigRepository)
	jobApplication := proposal2.NewExecuteProposal(ctx, executeProposalInputPort)
	jobJob := job.NewBaseJob(ctx, logger, jobApplication)
	diJob := &Job{
		Job: jobJob,
	}
	return diJob, func() {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

func InitProposalJobEval(ctx context.Context) (*Eval, func(), error) {
	environmentEnvironment := environment.ProvideEnvironment()
	logger, cleanup := zap.ProvideZapLogger(environmentEnvironment)
	llmClient := gemini.NewGeminiClient(ctx, environmentEnvironment)
	orchestrator := service7.NewOrchestrator(llmClient)
	summarizeService := service7.NewSummarizeService(llmClient)
	goalService := service7.NewGoalService(llmClient)
	terminator := service7.NewTerminator(llmClient)
	skipper := service7.NewSkipper(llmClient)
	promptBuilder := service8.NewPromptBuilder()
	planActionInterface := service9.NewPlanAction(llmClient, promptBuilder)
	webSearchClient := googlesearch.NewGoogleSearchClient(environmentEnvironment)
	documentSearchClient, cleanup2 := mock.NewMockDocumentSearchClient()
	searchTools := tools.NewSearchTools(llmClient, webSearchClient, documentSearchClient)
	externalSearchActionInterface := service9.NewExternalSearchAction(llmClient, searchTools, promptBuilder)
	internalSearchActionInterface := service9.NewInternalSearchAction(llmClient, searchTools, promptBuilder)
	analyzeActionInterface := service9.NewAnalyzeAction(llmClient, promptBuilder)
	writeActionInterface := service9.NewWriteAction(llmClient, promptBuilder)
	reviewActionInterface := service9.NewReviewAction(llmClient, promptBuilder)
	actionFactory := service9.NewActionFactory(planActionInterface, externalSearchActionInterface, internalSearchActionInterface, analyzeActionInterface, writeActionInterface, reviewActionInterface)
	reportRepository := memory.NewMemoryReportRepository()
	actionRepository := memory.NewMemoryActionRepository()
	judge := llmasjudge.NewJudge(llmClient)
	evaluator := proposaljob.NewProposalJobEval(orchestrator, summarizeService, goalService, terminator, skipper, actionFactory, reportRepository, actionRepository, judge)
	baseEvaluator := evaluate.NewBaseEvaluator(logger, evaluator)
	eval := &Eval{
		Evaluator: baseEvaluator,
	}
	return eval, func() {
		cleanup2()
		cleanup()
	}, nil
}
